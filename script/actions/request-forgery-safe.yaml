# Safe workflow demonstrating proper patterns for network requests
# This workflow shows how to safely make network requests without SSRF vulnerabilities

name: Safe Network Requests Workflow

on:
  # Even with privileged triggers, these patterns are safe
  pull_request_target:
    types: [opened, synchronize]
  issue_comment:
    types: [created]

jobs:
  # Safe: Using environment variables instead of direct expression interpolation
  safe-curl-with-env:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe curl using environment variable
        env:
          # Pass untrusted input through environment variable
          # This prevents shell injection but SSRF risk still exists
          # Additional validation is recommended
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          # Use environment variable instead of direct interpolation
          # Still need validation for SSRF, but prevents shell injection
          echo "Input received: $ISSUE_BODY"
          # Validate URL before use (example validation)
          if [[ "$ISSUE_BODY" =~ ^https://api\.example\.com/ ]]; then
            curl "$ISSUE_BODY"
          else
            echo "Invalid URL"
            exit 1
          fi

  # Safe: Hardcoded trusted URLs
  safe-hardcoded-url:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe curl with hardcoded URL
        run: |
          # Hardcoded trusted URL - no SSRF risk
          curl "https://api.github.com/repos/${{ github.repository }}"

  # Safe: Using trusted context values
  safe-trusted-context:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe curl with trusted context
        run: |
          # github.repository and github.sha are trusted
          curl "https://api.github.com/repos/${{ github.repository }}/commits/${{ github.sha }}"

  # Safe: URL allowlist validation
  safe-allowlist:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe curl with URL allowlist
        env:
          INPUT_URL: ${{ github.event.issue.body }}
        run: |
          # Validate URL against allowlist
          ALLOWED_DOMAINS="api.github.com api.example.com"

          # Extract domain from URL
          DOMAIN=$(echo "$INPUT_URL" | sed -E 's|^https?://([^/]+).*|\1|')

          # Check if domain is in allowlist
          if echo "$ALLOWED_DOMAINS" | grep -qw "$DOMAIN"; then
            curl "$INPUT_URL"
          else
            echo "Domain not in allowlist: $DOMAIN"
            exit 1
          fi

  # Safe: GitHub Script with environment variable
  safe-github-script:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe fetch in github-script
        uses: actions/github-script@v6
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        with:
          script: |
            // Use process.env instead of direct interpolation
            const inputUrl = process.env.ISSUE_BODY;

            // Validate URL before use
            const allowedHosts = ['api.github.com', 'api.example.com'];
            try {
              const url = new URL(inputUrl);
              if (!allowedHosts.includes(url.host)) {
                throw new Error(`Host not allowed: ${url.host}`);
              }

              const response = await fetch(inputUrl);
              const data = await response.json();
              console.log(data);
            } catch (error) {
              console.error('Invalid or disallowed URL:', error.message);
            }

  # Safe: Using GitHub API through octokit
  safe-octokit:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe API call using octokit
        uses: actions/github-script@v6
        with:
          script: |
            // Using octokit for GitHub API - no SSRF risk
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            console.log(`Found ${issues.length} open issues`);

  # Safe: Fixed API endpoints
  safe-api-endpoint:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe curl to fixed endpoint
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Only the numeric ID is variable, endpoint is fixed
          # This is safe as PR_NUMBER should be numeric
          if [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
            curl "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER"
          else
            echo "Invalid PR number"
            exit 1
          fi

  # Safe: Internal service with validated path
  safe-internal-service:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Safe internal service call
        env:
          USER_INPUT: ${{ github.event.issue.title }}
        run: |
          # Sanitize input to prevent path traversal and SSRF
          # Remove any characters that could be used for URL manipulation
          SAFE_INPUT=$(echo "$USER_INPUT" | tr -cd 'a-zA-Z0-9_-')

          # Use fixed internal endpoint with sanitized parameter
          curl "https://internal-api.example.com/search?q=${SAFE_INPUT}"

  # Safe: No network commands at all
  safe-no-network:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Process without network requests
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          # Process input locally without making network requests
          echo "Processing: $ISSUE_BODY"
          # Do local processing only

  # Safe: Block internal IPs before request
  safe-block-internal:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Block internal IPs
        env:
          INPUT_URL: ${{ github.event.comment.body }}
        run: |
          # Block requests to internal/metadata IPs
          BLOCKED_PATTERNS="169.254. 127. 10. 192.168. 172.16. 172.17. 172.18. 172.19. 172.20. 172.21. 172.22. 172.23. 172.24. 172.25. 172.26. 172.27. 172.28. 172.29. 172.30. 172.31. localhost metadata.google"

          for pattern in $BLOCKED_PATTERNS; do
            if echo "$INPUT_URL" | grep -q "$pattern"; then
              echo "Blocked: URL contains internal/metadata address pattern: $pattern"
              exit 1
            fi
          done

          echo "URL passed validation"
          # Additional domain allowlist check recommended before actual request
